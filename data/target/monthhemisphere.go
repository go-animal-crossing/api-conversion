package target

import (
	"acnh/utility"
	"fmt"
	"time"
)

// WithText generates a nicely formatted string of months
func (mh *MonthHemisphere) WithText() MonthHemisphere {
	// generate the sequence set
	mh.Sequences = mh.generateSequences(mh.Array)
	mh.Text = mh.sequencesToText(mh.Sequences)
	return *mh
}

// Is provides an updated set of IsConfig based on the time passed
// - this contains flags for new, available, leaving
func (mh *MonthHemisphere) Is(t time.Time) IsConfig {
	return IsConfig{
		Time:       t,
		New:        mh.new(t),
		Availabile: mh.available(t),
		Leaving:    mh.leaving(t)}
}

// available returns true if either the boolean is set or its in the .Array
func (mh *MonthHemisphere) available(t time.Time) bool {
	return mh.Always || mh.containsMonth(int(t.Month()), mh.Array)
}

// new returns true if the month (t) is the first item inside a sequence
func (mh *MonthHemisphere) new(t time.Time) bool {
	// if always available, then never new
	if mh.Always == true {
		return false
	}
	firsts := mh.getNFromSequence(0)
	m := int(t.Month())
	return mh.containsMonth(m, firsts)
}

// leaving returns true if the month (t) is the first item inside a sequence
func (mh *MonthHemisphere) leaving(t time.Time) bool {
	// if always available, then never leaving
	if mh.Always == true {
		return false
	}
	lasts := mh.getNFromSequence(-1)
	m := int(t.Month())
	return mh.containsMonth(m, lasts)
}

// getNFromSequence cherry picks the Nth item each sequence,
// or the last if its -1
func (mh *MonthHemisphere) getNFromSequence(n int) (ns []int) {
	// go over each sequence
	for _, seq := range mh.Sequences {
		check := n
		if n == -1 {
			check = len(seq) - 1
		}
		ns = append(ns, seq[check])
	}
	return
}

// containsMonth checks the Array data to see if the month asked for exists in there
func (mh *MonthHemisphere) containsMonth(month int, arr []int) bool {
	for _, m := range arr {
		if m == month {
			return true
		}
	}
	return false
}

// sequencesToText converts the sequence map generated by generateSequences
// into a textual representation
// 0:[1,2], 1:[9,10] => Jan - Feb, Sept - Oct
func (mh *MonthHemisphere) sequencesToText(sequences [][]int) string {

	dateString := ""
	// date format to use for outputting string (currently full month name)
	f := mh.dateFormat()

	for i, sequence := range sequences {
		// first item in the slice
		// - grab and generate a Time
		first := sequence[0]
		firstDate := mh.month(first)
		// always have a "," at the start, unless this is the first item
		prefix := ", "
		if i == 0 {
			prefix = ""
		}

		dateString = fmt.Sprintf("%s%s%s", dateString, prefix, firstDate.Format(f))

		l := len(sequence)

		if l > 1 {
			last := sequence[l-1]
			lastDate := mh.month(last)
			dateString = fmt.Sprintf("%s - %s", dateString, lastDate.Format(f))
		}

	}
	//fmt.Printf("%v => %v\n", sequences, dateString)
	return dateString

}

// dateFormat helper to return the string format we want to use
func (mh *MonthHemisphere) dateFormat() string {
	return "January"
}

// month is a quick wrapper func to get a time object for a month
func (mh *MonthHemisphere) month(month int) time.Time {
	return utility.MonthToTime(month)

}

// generateSequences converts the single flat version
// like [1,2,3, 8,9,10] to multi levels like [1,2,3], [8,9,10]
// this then used to generate text string representing those time
// ranges
func (mh *MonthHemisphere) generateSequences(numbers []int) [][]int {

	max := 12
	current := numbers[0] - 1
	sequence := make([]int, 0)
	sequences := make([][]int, 0)
	// what doing here is looping over set of ints and appending
	// to a slice of ints
	for i := 0; i < len(numbers); i++ {
		num := numbers[i]
		test := current + 1
		//fmt.Printf("[%v - %v - %v]\n", num, current, test)
		// this triggers the next index in the main slice by appending and clearing current
		if test != num {
			sequences = append(sequences, sequence)
			//fmt.Printf("sequence complete: \n%v\n%v\n", sequence, sequences)
			//fmt.Printf("next sequence starting: %v\n", sequence)
			sequence = make([]int, 0)
		}

		sequence = append(sequence, num)
		current = num % max
	}
	// append the last sequence
	sequences = append(sequences, sequence)

	return sequences
}
